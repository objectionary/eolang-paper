% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

\section{Foundations}

In this section, we introduce the core concepts of the calculus.
The purpose of this section is to define the entities that constitute the calculus---such as
  expressions, formations, attributes, and scope---together with their structural relationships.
The definitions given here are descriptive rather than operational.
They explain what expressions are, not how they are evaluated or transformed.

\subsection{Expression}\label{sec:expression}

\begin{definition}[Expression]
An \textbf{expression}, ranged over \(\mathcal{E}\) by \(e_i\),
  is a grammatical construct obeying the syntax of \cref{fig:ebnf}.
\end{definition}

\subsection{Attribute}\label{sec:attribute}

\begin{definition}[Attribute]
An \textbf{attribute}, ranged over \(\mathcal{T}\) by \(\tau_i\),
  is an identifier to which either $?$ or an expression
  may be attached.
\end{definition}

\begin{definition}[Void vs. Attached]
An attribute is \textbf{void} if $?$ is attached to it,
  otherwise it is an \textbf{attached} attribute.
\end{definition}

\subsection{Data}\label{sec:data}

\begin{definition}[Data]
\textbf{Data}, ranged over \(\mathcal{D}\) by \(\delta_i\), is a possibly empty sequence of 8-bit bytes.
\end{definition}

\subsection{Function}\label{sec:function}

\begin{definition}[Function]
A \textbf{function} is a total mapping
\(\langle \mathcal{B}, \mathcal{B}, \mathcal{S} \rangle \to \langle \mathcal{B}, \mathcal{S} \rangle\)
  that maps formation to formation, possibly modifying the \emph{state} of evaluation \(s_i\),
  which itself ranges over \(\mathcal{S}\).
\end{definition}

\subsection{Asset}\label{sec:asset}

\begin{definition}[Asset]
An \textbf{asset} is an identifier to which either data
  (denoted as $D$-asset) or function
  (denoted as $L$-asset) is attached.
\end{definition}

\subsection{Formation}\label{sec:formation}

\begin{definition}[Formation]
A \textbf{formation}, denoted as $[[ B ]]$, ranged over \(\mathcal{B}\) by \(b_i\),
is a non-empty ordered set of key-value pairs, where all keys are unique;
every formation has a mandatory attribute $^$.
\end{definition}

The predicate \(k \in B\) holds if \(k\) is present in any pair in \(B\).

We introduce the term \enquote{formation} rather than using the more traditional term \enquote{construction}
  because the latter generally implies the presence of a
  class from which an object is being constructed or instantiated.
Instead, formation is closer to the creation of a prototype, which may either be used \enquote{as is} or copied.

The following is an example of a formation with four pairs, where the first one
  is an asset attached to data, while the other three are attributes attached to
  expressions:
\begin{phiquation}
\label{eq:object-example}
 [[ D> 00-2A, |a| -> b_2(~0 -> b_3).bar, |b| -> [[ L> |Sqrt| ]], foo -> T ]].
\end{phiquation}

The arrow $ -> $ denotes an attachment of an expression (right-hand side)
  to an attribute (left-hand side).
The arrow $ ..> $ denotes an attachment of data or function to an asset.

\subsection{Domain}\label{sec:domain}

\begin{definition}[Domain]
A \textbf{domain} of formation \(b\), denoted as \(\bar{b}\), is an ordered set of all attributes of \(b\), excluding assets.
\end{definition}

The domain of the formation in \cref{eq:object-example} is \(\{ \ff{a}, \ff{b}, \ff{foo} \}\).
Assets $D$ and $L$ do not belong to the domain.

\subsection{Program}\label{sec:program}

\begin{definition}[Program]
A \textbf{program}, also known as \emph{Universe}, is a formation attached to $Q$.
\end{definition}

\subsection{Terminator}\label{sec:terminator}

\begin{definition}[Terminator]
The \textbf{terminator}, denoted as $T$, is an expression that signals an error.
\end{definition}

\subsection{Abstract}\label{sec:abstract}

\begin{definition}[Abstract]
An \textbf{abstract} is a formation with at least one void attribute.
\end{definition}

\Cref{eq:price-color} is an example of a formation that is an abstract,
  while the expression attached to its \ff{color} attribute is not an abstract.

A formation that is not an abstract may be called a \emph{closed} formation.

\subsection{Ordinal}\label{sec:ordinal}

\newcommand\ordinal[2]{#1 \circ #2}
\begin{definition}[Ordinal]
An attribute's \textbf{ordinal}, denoted as \(\ordinal{\tau}{b}\),
  is a non-negative whole number that is equal to the position of \(\tau\)
  in \(\bar{b}\), starting from zero.
\end{definition}

\begin{example}
\Cref{tab:ordinals} shows a few examples of attributes and their ordinals.

\begin{table*}
\capt{A few examples of attributes' ordinals in their formations.}
\label{tab:ordinals}
\begin{tabular}{lr}
\toprule
\(b\) & \(\ordinal{\ff{x}}{b}\) \\
\midrule
$[[ |x| -> \phiTerminal{\xi}.|k| ]]$
  & 0 \\
$[[ |foo| -> \phiTerminal{\xi}.|k|, |x| -> Q.|t| ]]$
  & 1 \\
$[[ L> |Fn|, |x| -> \phiTerminal{\xi}.|k| ]]$
  & 0 \\
$[[ D> CA-FE, |foo| -> \phiTerminal{\xi}, |x| -> \phiTerminal{\xi}.|foo| ]]$
  & 2 \\
\bottomrule
\end{tabular}
\end{table*}
\end{example}

\subsection{Application}\label{sec:application}

\begin{definition}[Application]
An \textbf{application}, denoted as $ e_1 ( \tau -> e_2 ) $,
  means an attempt to attach \(e_2\) (the \enquote{argument}) to the \(\tau\) attribute of \(e_1\)
  (the \enquote{subject}).
\end{definition}

\Cref{eq:simple-application} demonstrates application,
  where $ |a| -> b_2 $ is applied to an abstract $[[ |a| -> ? ]]$.
The application creates a new formation $[[ |a| -> b_2 ]]$,
  while the existing formation remains intact.

The formation in \cref{eq:price-color} is an abstract, because its attribute \ff{price} is void.
The formation in \cref{eq:simple-application} was an abstract before the application,
  but the formation created by the application is closed since its attribute \ff{a} is not void (attached to \(b_2\)).

Even though $?$ being attached to an attribute of a formation resembles NULL references, there is a significant difference:
  in \phic{}, void attributes may be attached to expressions only once,
  while any further reattachments are prohibited.

In $b(\phiTerminal{\alpha_i} -> e)$ application, \(e\) must be attached to the attribute \(\tau\) of \(b\)
  for which \(\ordinal{\tau}{\bar{b}}\) equals \(i\).

\subsection{Dispatch}\label{sec:dispatch}

\begin{definition}[Dispatch]
A \textbf{dispatch}, denoted as $ e . \tau $, where \(e\) is the \enquote{subject,}
  means retrieval of what is attached to \(\tau\).
\end{definition}

\subsection{Scope}\label{sec:scope}

\begin{definition}[Scope]
The \textbf{scope} of expression \(e\), denoted as \(e^\varsigma\), is either
  \begin{inparaenum}[a)]
  \item the formation where the expression is attached to an attribute,
  \item or the scope of the subject of the application where \(e\) is the argument.
  \end{inparaenum}
\end{definition}

Informally, the scope is the formation that is the \enquote{closest} to the pair, moving to the left in the expression.
In~\cref{eq:simple-scope}, the scope of \ff{author} is the formation where the \ff{source} attribute stays,
  while the scope of \ff{cite} is the formation where the \ff{ref} attribute stays.
\begin{phiquation}
\label{eq:simple-scope}
[[ ref -> \phiOver{ [[ source -> Q.book( author -> b_1 ) ]] }, cite -> b_2 ]]
\end{phiquation}

\Cref{fig:scopes} illustrates the concept of scope.

\begin{figure*}
\begin{mdframed}
\begin{phiquation*}
[[ |a| -> \phiOver{ [[ |y| -> b_2.|t|( |f| -> [[ |z| -> b_3 ]] ( |x| -> e ) ) ]] } ]]

[[ |f| -> \phiOver{ [[ |k| -> b_1( |x| -> e ) ]] } ]]

[[ |k| -> [[ |y| -> b( |f| -> \phiOver{ [[ |x| -> e ]] } ) ]] ]]

[[ |k| -> \phiOver{ [[ |f| -> [[ |x| -> ? ]] ( |x| -> b_2 ) ( |x| -> b_3 ) ( |x| -> e ) ]] } ]]
\end{phiquation*}
\end{mdframed}
\capt{Illustrative examples of scopes: the bars over the terms highlight \(e^\varsigma\), the scope of \(e\).}
\label{fig:scopes}
\end{figure*}

\subsection{Locators}\label{sec:locators}

In an expression, the locator $Q$ means the program, while the locator \phiTerminal{\(\xi\)} means the scope of the expression.

\subsection{Head and Tail}

\begin{definition}
Since any expression may recursively be defined as \begin{inparaenum}[1)]
    \item $T$,
    \item formation,
    \item application,
    or
    \item dispatch,
\end{inparaenum}
it consists of a \textbf{head} and a possibly empty \textbf{tail}, denoted together as \(h\bullet{}t\).
\end{definition}

\begin{example}
\Cref{tab:head-and-tail} shows a few examples that demonstrate the separation between a head and a possibly empty tail of an expression.

\begin{table*}
\capt{A few examples that demonstrate the separation between a head and a possibly empty tail of an expression.}
\label{tab:head-and-tail}
\begin{tabular}{lll}
\toprule
Expression & Head & Tail \\
\midrule
$b_1( foo -> b_2 )$
  & $b_1( foo -> b_2 )$
  & --- \\
$b_1.|aa|.|bb|( ~0 -> b_2 )$
  & $b_1$
  & $aa.bb( ~0 -> b_2 )$ \\
$[[ |a| -> b_2 ]].|aa|.|test|.|bb|$
  & $[[ |a| -> b_2 ]]$
  & $aa.test.bb$ \\
$b_1( |foo| -> b_2)( ~0 -> 42 ).|print|( ~1 -> 7 )$
  & $b_1( |foo| -> b_2)( ~0 -> 42 )$
  & $|print|( ~1 -> 7 )$ \\
\bottomrule
\end{tabular}
\end{table*}
\end{example}

\subsection{Atoms}\label{sec:atoms}

\begin{definition}[Atom]
An \textbf{atom} is an formation with a function attached to its $L$-asset.
\end{definition}

\Cref{eq:Sqrt} demonstrates an atom with a function that calculates the square root of a number,
  which it retrieves from the $D$-asset
  of $b.~0$ with the help of the morphing function (\cref{sec:morphing}).
The implementation of functions is outside the scope of \phic{}: they may be implemented,
  for example, in \(\lambda\)-calculus or a programming language such as Java or C++.

\subsection{Decoration}\label{sec:decoration}

\begin{definition}[Decoration]
\textbf{decoration} is a mechanism of extending a formation (``decoratee'')
  by attaching it to the $@$-attribute of a formation (``decorator''),
  which makes attributes of the decoratee retrievable from the decorator,
  unless the decorator has its own attributes with the same names.
\end{definition}

\subsection{Parent}

\begin{definition}[Parent]
Attaching expression \(e\) to the $^$ attribute of formation \(b\)
  means setting the \textbf{parent} of \(b\) to \(e\).
\end{definition}

The presence of \enquote{parent} in each formation is essential for the coordination of inner formations after dispatch.
Consider the following abstract with an inner formations:
\begin{phiquation*}
\Big\{ |x| -> [[ |a| -> ?, next -> [[ @ -> $.^.~0.plus( 1 ), ^ -> Q.|x| ]] ]], |k| -> $.|x|( |42| ) \Big\} {.}
\end{phiquation*}
Here, if the parent of $Q.|x|.|next|$ were attached in the formation,
  the result of $\mathbb{D}( Q.|k|.|next| )$
  would not be equal to \ff{43}.
Instead, it would be equal to $T$, because $ Q.|k|.|next|.^ $
  would still be attached to $ Q.|x| $ after the dispatch of $ Q.|k|.next $.
The parent attribute may be compared with the \ff{this} pointer in Java or C++, which
  does not point anywhere until a method of a class is called.
Then, when the method is called, the \ff{this} pointer refers to the formation that owns the method.

\subsection{Primitives}\label{sec:primitives}

\begin{definition}[Primitive]
A \textbf{primitive}, denoted by \(p\) and ranging over \(\mathcal{P} \in \mathcal{E}\),
  is either $T$ or formation without $L$-asset.
\end{definition}
