% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

\section{Foundations}

In this section we introduce the core concepts of the calculus.
The purpose of this section is to define the entities that constitute the calculus---such as
  expressions, objects, attributes, bindings, and scope---together with their structural relationships.
The definitions given here are descriptive rather than operational.
They explain what expressions and objects are, not how they are evaluated or transformed.

\subsection{Expression}\label{sec:expression}

\begin{definition}[Expression]
An \textbf{expression}, ranged over \(\mathcal{E}\) by \(e_i\),
is a grammatical construct that may result in an object after
certain transformations.
\end{definition}

\subsection{Attribute}\label{sec:attribute}

\begin{definition}[Attribute]
An \textbf{attribute}, ranged over \(\mathcal{T}\) by \(\tau_i\),
  is an identifier to which either \stx{\varnothing} or an expression
  may be attached.
\end{definition}

\begin{definition}[Void vs. Attached]
An attribute is \textbf{void} if \stx{\varnothing} is attached to it,
  otherwise it is an \textbf{attached} attribute.
\end{definition}

\subsection{Data}\label{sec:data}

\begin{definition}[Data]
A \textbf{data}, ranged over \(\mathcal{D}\) by \(\delta_i\), is a possibly empty sequence of 8-bit bytes.
\end{definition}

\subsection{Binding}\label{sec:binding}

\begin{definition}[Binding]
A \textbf{binding}, ranged over \(\mathcal{G}\) by \(B\), is a possibly empty
  ordered set of key-value pairs, denoted as
  \( k_1 \to v_1, k_2 \to v_2, \dots, k_n \to v_n \), where all keys are unique.
\end{definition}

The predicate \(k \in B\) holds if \(k\) is present in any pair of \(B\).

\subsection{Function}\label{sec:function}

\begin{definition}[Function]
A \textbf{function} is a total mapping
\(\langle \mathcal{G}, \mathcal{S} \rangle \to \langle \mathcal{G}, \mathcal{S} \rangle\)
  that maps binding to binding, possibly modifying the \emph{state} of evaluation \(s_i\),
  which itself ranges over \(\mathcal{S}\).
\end{definition}

\subsection{Asset}\label{sec:asset}

\begin{definition}[Asset]
An \textbf{asset} is an identifier to which either data
  (denoted as \stx{\Delta}-asset) or function
  (denoted as \stx{\lambda}-asset) is attached.
\end{definition}

\subsection{Object}\label{sec:object}

\begin{definition}[Object]
An \textbf{object}, ranged over \(\mathcal{B}\) by \(b_i\), is a binding
  where keys are either attributes or assets and values are either
  \stx{\varnothing}, expressions, data, or functions.
\end{definition}

\subsection{Domain}\label{sec:domain}

\begin{definition}[Domain]
A \textbf{domain} of object \(b\), denoted as \(\bar{b}\), is a set
that includes all attributes of \(b\).
\end{definition}

The domain of the object in \cref{eq:object-example} is \(\{ \ff{a}, \ff{b}, \ff{foo} \}\).
Assets \stx{\Delta} and \stx{\lambda} do not belong to object domain.

\subsection{Formation}\label{sec:formation}

\begin{definition}[Formation]
Object \textbf{formation}, denoted as \(\stx{\llbracket} B \stx{\rrbracket}\),
  is a construction of a new object.
\end{definition}

We introduce the term ``object formation'' rather than using the more traditional
term ``construction'' because the latter generally implies the presence of a
class from which an object is being constructed or instantiated. Instead,
object formation is closer to the creation of a prototype, which may either be
used ``as is'' or copied.

The following is an example of an object formation with four pairs, where the first one
  is an asset attached to data, while the other three are attributes attached to
  expressions:
\begin{phiquation}
\label{eq:object-example}
[[ D> 00-2A, |a| -> b_2(0-> b_3).bar, |b| -> [[ L> |Sqrt| ]], foo -> \dead ]].
\end{phiquation}

The arrow \stx{\mapsto} denotes an attachment of an expression (right-hand side)
  to an attribute (left-hand side). The arrow \stx{\phiDotted} denotes
  an attachment of data or function to an asset.

\subsection{Program}\label{sec:program}

\begin{definition}[Program]
A \textbf{program} is a pair $ Q \stx{ -> } \stx{ [[ } B \stx{ ]] } $ that exists outside of any objects.
\end{definition}

The object attached to \(\Phi\) is called \emph{Universe}.

\subsection{Abstract Object}\label{sec:abstract}

\begin{definition}[Abstract Object]
An object is \textbf{abstract} if at least one of its attributes is void,
otherwise the object is \textbf{closed}.
\end{definition}

\Cref{eq:price-color} is an example of an object formation, where the binding of
the abstract object being formed consists of two pairs: $price -> ?$ and
$color -> [[ D> FF-C0-CB ]]$. The object attached to the |color| attribute is a
formation of a closed object.

\subsection{Ordinal}\label{sec:ordinal}

\newcommand\ordinal[2]{#1 \circ #2}
\begin{definition}[Ordinal]
An attribute's \textbf{ordinal}, denoted as \(\ordinal{\tau}{b}\),
is a non-negative whole number that is equal to the position of \(\tau\)
in \(\mathbb{F}(b)\), starting from zero, not counting assets.
\end{definition}

\begin{example}
\Cref{tab:ordinals} shows a few examples of attributes and their ordinals.

\begin{table*}
\capt{A few examples of attributes' ordinals in their objects.}
\label{tab:ordinals}
\begin{tabular}{lr}
\toprule
\(b\) & \(\ordinal{|x|}{b}\) \\
\midrule
$[[ |x| -> \xi.|k| ]]$
  & 0 \\
$[[ |foo| -> \xi.|k|, |x| -> \Phi.|t| ]]$
  & 1 \\
$[[ L> |Fn|, |x| -> \xi.|k| ]]$
  & 0 \\
$[[ D> CA-FE, |foo| -> \xi, |x| -> \xi.|foo| ]]$
  & 2 \\
\bottomrule
\end{tabular}
\end{table*}
\end{example}

\subsection{Application}\label{sec:application}

\begin{definition}[Application]
Object \textbf{application}, denoted as \( b \stx{(} \tau \;\stx{\mapsto}\; e \stx{)} \), is a copy of an existing abstract object \(b\) (the ``subject''), with \(e\) attached to its \(\tau\) attribute.
\end{definition}

\Cref{eq:simple-application} demonstrates object application, where $ |a| -> b_2 $ is
applied to the formation of an abstract object $[[ |a| -> ? ]]$. The application creates
a new object $[[ |a| -> b_2 ]]$, while the existing abstract object remains intact.

The object in \cref{eq:price-color} is abstract, because its attribute \ff{price} is void.
The object in \cref{eq:simple-application} was abstract before the application, but the object created by the application is closed since its attribute \ff{a} is not void (attached to \(b_2\)).

Even though \stx{\varnothing} may be attached to an attribute of an object,
it is not an object by itself. Instead, \(\varnothing\) is a ``placeholder''
for an object, which remains attached to an attribute until an object is attached to it.
Even though this mechanism resembles NULL references, there is a significant
difference: in \phic{}, void attributes may be attached to objects only once,
while any further reattachments are prohibited.

In $b(\alpha_i -> e)$ application, \(e\) must be attached to the attribute \(\tau\) of \(b\) for which \(\ordinal{\tau}{\mathbb{F}(b)}\) equals \(i\).

\subsection{Forma}\label{sec:forma}

\begin{definition}[Forma]
A \textbf{forma} of an object \(b\), denoted as \(\mathbb{F}(b)\), is an abstract
object that was copied in order to create \(b\).
A forma of a formation is the formation itself.
\end{definition}

In \cref{eq:simple-application}, the forma of $[[ |a| -> b_2 ]]$ is the abstract
object $[[ |a| -> ? ]]$, while the forma of $[[ |a| -> ? ]]$ is itself.

\subsection{Dispatch}\label{sec:dispatch}

\begin{definition}[Dispatch]
Object \textbf{dispatch} (also known as ``dot notation''), denoted as
\( b \stx{.} \tau \) where \(b\) is the ``subject'', means retrieval of the object
attached to the \(\tau\) attribute of \(b\).
\end{definition}

\subsection{Scope}\label{sec:scope}

\begin{definition}[Scope]
The \textbf{scope} of expression \(e\), denoted as \(e^\varsigma\) is either
\begin{inparaenum}[a)]
\item the formation where the expression is attached to an attribute,
\item or the scope of the expression where \(e\) is used.
\end{inparaenum}
\end{definition}

In simpler terms, the scope is the formation that is the ``closest'' to the pair, moving to the left in the expression.
In~\cref{eq:simple-scope}, the scope of \ff{author} is the formation where the \ff{source} attribute stays, while the scope of \ff{cite} is the formation where the \ff{ref} attribute stays.
\begin{phiquation}
\label{eq:simple-scope}
  [[ ref -> \phiOver{ [[ source -> Q.book( author -> b_1 ) ]] }, cite -> b_2 ]]
\end{phiquation}

\Cref{fig:scopes} illustrates the concept of scope of a pair.

\begin{figure*}
\begin{mdframed}
\begin{phiquation*}
[[ |a| -> \phiOver{ [[ |y| -> b_2.|t|( |f| -> [[ |z| -> b_3 ]] ( |x| -> e ) ) ]] } ]]

[[ |f| -> \phiOver{ [[ |k| -> b_1( |x| -> e ) ]] } ]]

[[ |k| -> [[ |y| -> b( |f| -> \phiOver{ [[ |x| -> e ]] } ) ]] ]]

[[ |k| -> \phiOver{ [[ |f| -> [[ |x| -> ? ]] ( |x| -> b_2 ) ( |x| -> b_3 ) ( |x| -> e ) ]] } ]]
\end{phiquation*}
\end{mdframed}
\label{fig:scopes}
\capt{Illustrative examples of scopes: the bars over the terms highlight \(e^\varsigma\), the scope of \(e\).}
\end{figure*}

\subsection{Locators}\label{sec:locators}

In an expression, the locator \stx{\Phi} means the program,
while the locator \stx{\xi} means the scope of the expression.

\subsection{Head and Tail}

\begin{definition}
Since any expression may recursively be defined as either \begin{inparaenum}[1)]
    \item \(\stx{\dead}\),
    \item formation,
    \item application,
    or
    \item dispatch,
\end{inparaenum}
it consists of a \textbf{head} and a possibly empty \textbf{tail}, denoted together as \(h\bullet{}t\).
\end{definition}

\begin{example}
\Cref{tab:head-and-tail} shows a few examples that demonstrate the separation
between a head and a possibly empty tail of an expression.

\begin{table*}
\capt{A few examples of objects that demonstrate the separation between a head and a possibly empty tail of an expression.}
\label{tab:head-and-tail}
\begin{tabular}{lll}
\toprule
Expression & Head & Tail \\
\midrule
$b_1( foo -> b_2 )$
  & $b_1( foo -> b_2 )$
  & --- \\
$b_1.\alpha_1.\alpha_2( 0-> b_2 )$
  & $b_1$
  & $\alpha_1.\alpha_2( 0-> b_2 )$ \\
$[[ |a| -> b_2 ]].|a|.|test|.|b|$
  & $[[ |a| -> b_2 ]]$
  & $\alpha_0.|test|.\alpha_2$ \\
$b_1( |foo| -> b_2)( 0-> 42 ).|print|( 1-> 7 )$
  & $b_1( |foo| -> b_2)( 0-> 42 )$
  & $|print|( 1-> 7 )$ \\
\bottomrule
\end{tabular}
\end{table*}
\end{example}

\subsection{Terminator}\label{sec:terminator}

\begin{definition}[Terminator]
The \textbf{terminator}, denoted as \stx{\dead}, is an object that equals itself when it is
the subject of a dispatch or an application:
\begin{equation*}
\forall \tau : \dead.\tau \trans \dead \qquad \forall \tau, e : \dead( \tau \mapsto e) \trans \dead.
\end{equation*}
\end{definition}

\subsection{Immutability}\label{sec:immutability}

\begin{definition}[Immutability]
Every object is \textbf{immutable}, meaning that an application of
its already attached attribute equals to \(\stx{\dead}\):
\begin{equation*}
\forall \tau, e_1, e_2 : \stx{\llbracket} \tau \stx{\mapsto} e_1 \stx{\rrbracket} \stx{(} \tau \stx{\mapsto} e_2 \stx{)} \trans \stx{\dead}
\end{equation*}
\end{definition}

\subsection{Atoms}\label{sec:atoms}

\begin{definition}[Atom]
An \textbf{atom} is an object with a function attached to its \stx{\lambda}-asset.
\end{definition}

\Cref{eq:Sqrt} demonstrates an atom with a function that calculates
the square root of a number, which it retrieves from the \stx{\Delta}-asset
of \(b\stx{.}\alpha_0\) with the help of the morphing function (\cref{sec:morphing}).
The implementation of functions is outside the scope of \phic{}: they may be implemented,
for example, in \(\lambda\)-calculus or a programming language
such as Java or C++.

\subsection{Decoration}\label{sec:decoration}

\begin{definition}[Decoration]
Object \textbf{decoration} is a mechanism of extending an object (``decoratee'')
by attaching it to the \stx{\varphi}-attribute of another object (``decorator''),
which makes attributes of the decoratee retrievable from the decorator,
unless the decorator has its own attributes with the same names.
\end{definition}

\subsection{Parent}

\begin{definition}[Parent]
Attaching expression \(e\) to the \stx{\rho} attribute of object \(b\)
  means setting the \textbf{parent} of \(b\) to \(e\).
\end{definition}

The presence of ``parent'' in each object is essential for the coordination of inner objects after dynamic dispatch.
Consider the following formation of an abstract object with an inner object:
\begin{phiquation*}
\Big\{ |x| -> [[ |a| -> ?, next -> [[ @ -> \xi.^.\alpha_0.plus( 1 ), ^ -> Q.|x| ]] ]], |k| -> \xi.|x|( |42| ) \Big\}.
\end{phiquation*}
Here, if the parent of \(\stx{\Phi}\stx{.}\ff{x}\stx{.}\ff{next}\) were attached in the formation,
  the result of \(\mathbb{D}(\stx{\Phi}\stx{.}\ff{k}\stx{.}\ff{next})\)
  would not be equal to \ff{43}.
Instead, it would be equal to \(\stx{\dead}\), because \(\stx{\Phi}\stx{.}\ff{k}\stx{.}\ff{next}\stx{.}\stx{\rho}\)
  would still be attached to \(\stx{\Phi}\stx{.}\ff{x}\) after the dispatch of \(\stx{\Phi}\stx{.}\ff{k}\stx{.}\ff{next}\).
The parent attribute may be compared with the \ff{this} pointer in Java or C++, which
  does not point anywhere until a method of a class is called.
Then, when the method is called, the \ff{this} pointer refers to the object that owns the method.

\subsection{Primitives}\label{sec:primitives}

\begin{definition}[Primitive]
A \textbf{primitive} denoted by \(p\) and ranging over \(\mathcal{P} \in \mathcal{N}\)
is either \(\stx{\dead}\) or object formation without \stx{\lambda}-asset.
\end{definition}
