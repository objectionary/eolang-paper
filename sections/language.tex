% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

% synthetic attributes
% const
% idempotence
% lints

% true, false, if
% try/catch
% seq, goto, while,
% tuples
% malloc
% number
% const

The entire syntax of the \eolang{} language in BNF is available on the first page of the \texttt{objectionary/eo} GitHub repository%
  \footnote{\url{https://github.com/objectionary/eo}}.
In this section, we only explain key concepts of the language.

\section{Informal Overview}

In runtime, every \eolang{} object is represented by an \emph{actor}.
On the surface, an actor resembles an associative array that responds to a few requests, where ``reference'' is a reference to an arbitrary actor:
\begin{enumerate}
  \item \ff{take(attr)} returns a reference, by provided attribute;
  \item \ff{put(attr, actor)} saves a reference, by the attribute;
  \item \ff{delta()} turns itself to data;
  \item \ff{copy()} makes a copy of itself.
\end{enumerate}

Consider the following code:

\begin{ffcode}
[qty price] > order (*@\label{ln:order-start}@*)
  qty.mul > cost
    price (*@\label{ln:order-stop}@*)
\end{ffcode}

The code is equivalent to the following \phic{} expression:
\begin{phiquation*}
\Big\{ order -> [[ qty -> ?, price -> ?, cost -> \xi.qty.mul(\xi.price) ]] \Big\}
\end{phiquation*}

\cref{fig:order} shows five actors that represent the code in runtime.
When being asked to \ff{take()}, actors behave differently.
Their behavior constitute the semantic of the language.

\begin{figure*}
\begin{mdframed}
\begin{tikzpicture}
[every node/.style={draw},
up/.style={draw=none, anchor=south west, label position=north west, align=left},
actor/.style={rotate=90, font={\scriptsize\sffamily}, draw=none, anchor=south west, label position=south west}]
\node [label={[up, text width=10em]$b_1=[[ qty -> ?, price -> ?, cost -> b_4, \rho -> ? ]]$}, label={[actor]formation}, fill=blue!5] (b1)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{qty}: & \(\varnothing\) \\
  \ff{price}: & \(\varnothing\) \\
  \ff{cost}: & \(b_4\) \\
  \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_2 = b_1.qty$}, label={[actor]dispatch}, above right=0 and 2.5 of b1, fill=green!5] (b2)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_1\) \\
  \ff{attr}: & \ff{qty} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_3 = b_2.mul$}, label={[actor]dispatch}, fill=green!5, right=of b2] (b3)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_2\) \\
  \ff{attr}: & \ff{mul} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_4 = b_3(0-> b_5)$}, label={[actor]application}, fill=red!5, below=of b3] (b4)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{prototype}: & \(b_3\) \\
  \ff{attr}: & \(\alpha_0\) \\
  \ff{argument}: & \(b_5\) \\
  \end{tabularx}}};
\node [label={[up]$b_5 = b_1.price$}, label={[actor]dispatch}, fill=green!5, left=of b4] (b5)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_1\) \\
  \ff{attr}: & \ff{price} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\end{tikzpicture}
\end{mdframed}
\capt{Actors representing the program at the lines \ref{ln:order-start}--\ref{ln:order-stop}.}
\label{fig:order}
\end{figure*}

\subsection{Application}

The actor representing \emph{application} contains
\begin{inparaenum}[1)]
\item a ``prototype'' reference,
\item an attribute,
and
\item an ``argument'' reference.
\end{inparaenum}

On any type of request, the actor
\begin{inparaenum}[1)]
\item asks prototype to \ff{copy()} expecting a ``copy'' actor to be returned,
\item asks the copy to \ff{put(attribute, argument)},
and
\item passes the request to the copy.
\end{inparaenum}

\subsection{Dispatch}

The actor representing \emph{dispatch} contains
\begin{inparaenum}[1)]
\item a ``base'' reference,
\item an attribute,
and
\item a mutable initially blank ``memo'' reference.
\end{inparaenum}

On any type of request, the actor does two things.
First, if memo is blank, it
\begin{inparaenum}[1)]
\item asks base to \ff{take(attribute)} expecting a target to be returned,
\item asks target to \ff{put(\(\rho\),base)},
and
\item saves target to the memo.
\end{inparaenum}
Then, it passes the request to the memo.

\subsection{Formation}

The actor representing \emph{formation} contains
\begin{inparaenum}[1)]
\item an associative array of attributes and references,
\item a possibly blank \(\lambda\)-asset,
and
\item a possibly blank \(\Delta\)-asset.
\end{inparaenum}

When being asked to \ff{put()}, the actor saves the reference to the array, if given attribute is not yet attached.
If the attribute is already attached, the actor returns an error.

When being asked to \ff{take()}, the actor returns the reference that corresponds to the given attribute.
If the attribute is attached to a blank, the actor returns an error.
If the attribute is absent and the \(\varphi\)-attribute is present, the actor asks the referenced actor by the attribute to \ff{take()}.
If the \(\varphi\)-attribute is present but the \(\lambda\)-asset is present, the actor calls the function attached to the asset, it returns a reference, and the actor uses it to \ff{take()}.
Otherwise, the actor returns an error.

When being asked to \ff{delta()}, the actor returns the \(\Delta\)-asset if it has one.
If it doesn't have it but the \(\lambda\)-asset is present, the actor calls the function attached to the \(\lambda\)-asset, gets a reference, and uses it to \ff{take()}.
If the \(\lambda\)-asset is also absent by the \(\varphi\)-attribute is present, the actor asks the referenced actor by the attribute to \ff{take()}.
Otherwise, the actor returns an error.
