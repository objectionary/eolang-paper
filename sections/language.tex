% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

% synthetic attributes
% const
% idempotence
% lints

% true, false, if
% try/catch
% seq, goto, while,
% tuples
% malloc
% number
% const

The entire syntax of the \eolang{} language in BNF is available on the first page of the \texttt{objectionary/eo} GitHub repository%
  \footnote{\url{https://github.com/objectionary/eo}}.
In this section, we only explain key concepts of the language.

\subsection{Informal Overview}

At runtime, every \eolang{} object consists of a few \emph{cells}.
A cell responds to a few requests, where ``reference'' resembles a pointer:
\begin{enumerate}
  \item \ff{take(attr)} --- returns a reference, by provided attribute;
  \item \ff{put(attr, cell)} --- stores a reference, by the attribute;
  \item \ff{delta()} --- turns itself to data;
  \item \ff{copy()} --- makes a copy of itself.
\end{enumerate}

\begin{figure*}
\begin{mdframed}
\ffinput{order/order.eo}
\end{mdframed}
\capt{Order object}
\label{fig:order}
\end{figure*}


Consider EO code at \cref{fig:order}, which is equivalent to the following expression:
\iexec[quiet,maybe]{eoc parse --sources=order}
\iexec[maybe]{phino rewrite --sweet --flat --nonumber --output=latex --input=xmir --canonize --hide=Q.order.ship.xiðŸŒµ --hide=Q.order.xiðŸŒµ < .eoc/1-parse/order.xmir}

\cref{fig:cells} shows the cells that represent the \ff{order} object at runtime.
When being asked to \ff{take()}, cells behave differently.
Their behavior constitutes the semantics of the language.
Cells belong to one of six types, denoted by different colors: application, dispatch, formation, decoration, atom, and payload.

\begin{figure*}
\begin{mdframed}
\begin{tikzpicture}
[every node/.style={draw},
up/.style={draw=none, anchor=south west, label position=north west, align=left},
cell/.style={rotate=90, font={\scriptsize\sffamily}, draw=none, anchor=south west, label position=south west, fill=gray!10}]
\node [label={[up, text width=10em]$c_1$}, label={[cell]decoration}, fill=orange!5] (c1)
  {\parbox{9em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{decorator}: & \(c_2\) \\
  \ff{decoratee}: & \(c_5\) \\
  \ff{memos}: & \(\langle\varnothing, \varnothing\rangle\) \\
  \end{tabularx}}};
\node [label={[up, text width=10em]$c_2=[[ qty -> ?, \newline price -> c_7, ship -> c_8 ]]$}, label={[cell]formation}, below=1.2 of c1, fill=blue!5] (c2)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{qty}: & \(\varnothing\) \\
  \ff{price}: & \(c_7\) \\
  \ff{ship}: & \(c_8\) \\
  \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_3 = c_0.qty$}, label={[cell]dispatch}, right=of c1, fill=green!5] (c3)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attribute}: & \ff{qty} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_4 = c_3.mul$}, label={[cell]dispatch}, fill=green!5, right=of c3] (c4)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_3\) \\
  \ff{attribute}: & \ff{mul} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_6 = c_0.price$}, label={[cell]dispatch}, fill=green!5, right=of c2] (c6)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attribute}: & \ff{price} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_5 = c_4(0-> c_6)$}, label={[cell]application}, fill=red!5, right=of c6] (c5)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{prototype}: & \(c_4\) \\
  \ff{attribute}: & \(\alpha_0\) \\
  \ff{argument}: & \(c_6\) \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_7 = \ff{19.99}$}, label={[cell]payload}, fill=cyan!5, below=of c2] (c7)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\Delta\): & \ff{19.99} \\
  \ff{base}: & \(\dead\) \\
  \end{tabularx}}};
\node [label={[up]$c_8 = [[ L> |F1| ]]$}, label={[cell]atom}, fill=purple!5, right=of c7] (c8)
  {\parbox{5em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\lambda\): & \ff{F1} \\
  \ff{base}: & \(c_9\) \\
  \end{tabularx}}};
\node [label={[up]$c_9 = [[ city -> ? ]]$}, label={[cell]formation}, fill=blue!5, right=of c8] (c9)
  {\parbox{5em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{city}: & \(\varnothing\) \\
  \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\end{tikzpicture}
\end{mdframed}
\capt{Cells representing the object \ff{order} of \cref{fig:order}.}
\label{fig:cells}
\end{figure*}

The following pseudo-code explains the semantic of every cell type:

\begin{ffcode}
Application(prototype, attribute, argument, memo):
  take(attr): return m().take(attr)
  put(attr, cell): fail
  delta(): return m().delta()
  copy(): return self
  m():
    if memo.blank():
      c = prototype.copy()
      c.put(attr, argument)
      memo.store(c)
    return memo.get()
\end{ffcode}

\begin{ffcode}
Dispatch(base, attribute, memo):
  take(attr): return m().take(attr)
  put(attr, cell): fail
  delta(): return m().delta()
  copy(): return self
  m():
    if memo.blank():
      c := base.take(attribute)
      c.put((*@\(\rho\)@*), base)
      memo.store(c)
    return memo.get()
\end{ffcode}

\begin{ffcode}
Formation(attributes):
  take(attr): return attributes.get(attr)
  put(attr, cell):
    if attributes.has(attr): fail
    attributes.put(attr, cell)
  delta(): fail
  copy(): return new Formation(attributes)
\end{ffcode}

\begin{ffcode}
Decoration(decorator, decoratee, memos):
  take(attr):
    if memos.absent(attr):
      c := decorator.get(attr)
      if c is (*@\(\dead\)@*):
        c := decoratee.get(attr)
      memos.put(attr, c)
    return memos.get(attr)
  put(attr, cell): fail
  delta(): fail
  copy(): return self
\end{ffcode}

\begin{ffcode}
Atom((*@\(\lambda\)@*), base):
  take(attr):
    c := base.get(attr)
    if c is (*@\(\dead\)@*):
      c := (*@\(\lambda(\ff{self})\)@*)
    return c
  put(attr, cell): base.put(attr, cell)
  delta(): return base.delta()
  copy(): return self
\end{ffcode}

\begin{ffcode}
Payload((*@\(\Delta\)@*), base):
  take(attr): return base.take(attr)
  put(attr, cell): base.put(attr, cell)
  delta(): return (*@\(\Delta\)@*)
  copy(): return self
\end{ffcode}

\subsection{Garbage Collection}

A function may create cells, but it man not delete them.
Instead, they get deleted automatically except the cell that the function returns and the cells directly or indirectly referenced by it.
