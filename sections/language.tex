% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

% synthetic attributes
% const
% idempotence
% lints

% true, false, if
% try/catch
% seq, goto, while,
% tuples
% malloc
% number
% const

\iexec[quiet,maybe]{eoc parse --sources=eo}

The entire syntax of the \eolang{} language in BNF is available on the first page of the \texttt{objectionary/eo} GitHub repository%
  \footnote{\url{https://github.com/objectionary/eo}}.
In this section, we only explain key concepts of the language.

\subsection{Forma Inference}

Consider a program with three objects:
\begin{multicols}{3}
\ffinput{eo/circle.eo}
\par\columnbreak\par
\ffinput{eo/app.eo}
\par\columnbreak\par
\ffinput{eo/number.eo}
\end{multicols}
The \ff{circle} object is equivalent to the following expression:
\iexec[maybe]{phino rewrite --sweet --flat --input=xmir --canonize --hide=Q.circle.xiðŸŒµ < .eoc/1-parse/circle.xmir > .eoc/circle.phi}
\iexec[maybe]{phino rewrite --sweet --flat --input=xmir --canonize --hide=Q.number.xiðŸŒµ --hide=Q.number.mul.xiðŸŒµ < .eoc/1-parse/number.xmir > .eoc/number.phi}
\iexec[maybe]{phino rewrite --sweet --flat --input=xmir --canonize --hide=Q.app.xiðŸŒµ < .eoc/1-parse/app.xmir > .eoc/app.phi}
\iexec[maybe]{phino merge .eoc/number.phi .eoc/app.phi .eoc/circle.phi runtime.phi --sweet --output=latex > _tex/program-circle.tex}

\subsection{Cells}

Consider this EO code:
\ffinput{eo/order.eo}
It is equivalent to the following expression:
\iexec[maybe]{phino rewrite --sweet --flat --label=eq:order --output=latex --input=xmir --canonize --hide=Q.order.ship.xiðŸŒµ --hide=Q.order.xiðŸŒµ < .eoc/1-parse/order.xmir}

In a VM, the object may be presented by a few \emph{cells}, as \cref{fig:cells} shows.
Cells belong to one of six types, denoted by different colors: application, dispatch, formation, decoration, atom, and payload.

\begin{figure*}
\begin{mdframed}
\begin{tikzpicture}
[every node/.style={draw},
up/.style={draw=none, anchor=south west, label position=north west, align=left},
cell/.style={rotate=90, font={\scriptsize\sffamily}, draw=none, anchor=south west, label position=south west, fill=gray!10}]
\node [label={[up, text width=10em]$c_1$}, label={[cell]decoration}, fill=orange!5] (c1)
  {\parbox{9em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{decorator}: & \(c_2\) \\
  \ff{decoratee}: & \(c_5\) \\
  \ff{memos}: & \(\langle\varnothing, \varnothing\rangle\) \\
  \end{tabularx}}};
\node [label={[up, text width=10em]$c_2=[[ qty -> ?, \newline price -> c_7, ship -> c_8 ]]$}, label={[cell]formation}, below=1.2 of c1, fill=blue!5] (c2)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{attributes}: \\
  \(\cdot\) \ff{qty}: & \(\varnothing\) \\
  \(\cdot\) \ff{price}: & \(c_7\) \\
  \(\cdot\) \ff{ship}: & \(c_8\) \\
  \(\cdot\) \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_3 = c_0.qty$}, label={[cell]dispatch}, right=of c1, fill=green!5] (c3)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attribute}: & \ff{qty} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_4 = c_3.mul$}, label={[cell]dispatch}, fill=green!5, right=of c3] (c4)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_3\) \\
  \ff{attribute}: & \ff{mul} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_6 = c_0.price$}, label={[cell]dispatch}, fill=green!5, right=of c2] (c6)
  {\parbox{9em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attribute}: & \ff{price} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_5 = c_4(0-> c_6)$}, label={[cell]application}, fill=red!5, right=of c6] (c5)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{prototype}: & \(c_4\) \\
  \ff{attribute}: & \(\alpha_0\) \\
  \ff{argument}: & \(c_6\) \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_7 = \ff{19.99}$}, label={[cell]payload}, fill=cyan!5, below=of c2] (c7)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\Delta\): & \ff{19.99} \\
  \ff{base}: & \(\dead\) \\
  \end{tabularx}}};
\node [label={[up]$c_8 = [[ L> |F1| ]]$}, label={[cell]atom}, fill=purple!5, right=of c7] (c8)
  {\parbox{5em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\lambda\): & \ff{F1} \\
  \ff{base}: & \(c_9\) \\
  \end{tabularx}}};
\node [label={[up]$c_9 = [[ city -> ? ]]$}, label={[cell]formation}, fill=blue!5, right=of c8] (c9)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{attributes}: \\
  \(\cdot\) \ff{city}: & \(\varnothing\) \\
  \(\cdot\) \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\end{tikzpicture}
\end{mdframed}
\capt{Cells representing the object of \cref{eq:order}.}
\label{fig:cells}
\end{figure*}

In a VM written in JavaScript, a cell would be an object with four methods:
\begin{ffcode}
take(attr) { /* Returns an attribute by name */ }
put(attr, cell) { /* Stores an attribute by name */ }
delta() { /* Turns itself to data */ }
copy() { /* Makes a copy of itself */ }
\end{ffcode}

\Cref{fig:js-cells} shows JavaScript code snippets that explain the semantic of every cell type.

\iexec[maybe]{find cells/ -name '*.js' -exec node \{\} \\;}

\begin{figure*}
\scriptsize
\begin{mdframed}
\begin{multicols}{2}
\ffinput{cells/formation.js}
\ffinput{cells/application.js}
\ffinput{cells/dispatch.js}
\ffinput{cells/decoration.js}
\ffinput{cells/atom.js}
\ffinput{cells/payload.js}
\end{multicols}
\end{mdframed}
\capt{Cells in JavaScript.}
\label{fig:js-cells}
\end{figure*}

\subsection{Garbage Collection}

A function may create cells, but it man not delete them.
Instead, they get deleted automatically except the cell that the function returns and the cells directly or indirectly referenced by it.
