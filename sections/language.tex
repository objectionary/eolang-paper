% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

% synthetic attributes
% const
% idempotence
% lints

% true, false, if
% try/catch
% seq, goto, while,
% tuples
% malloc
% number
% const

The entire syntax of the \eolang{} language in BNF is available on the first page of the \texttt{objectionary/eo} GitHub repository%
  \footnote{\url{https://github.com/objectionary/eo}}.
In this section, we only explain key concepts of the language.

\subsection{Informal Overview}

At runtime, every \eolang{} object consists of a few \emph{cells}.
A cell responds to a few requests, where ``reference'' resembles a pointer:
\begin{enumerate}
  \item \ff{take(attr)} --- returns a reference, by provided attribute;
  \item \ff{put(attr, cell)} --- saves a reference, by the attribute;
  \item \ff{delta()} --- turns itself to data;
  \item \ff{copy()} --- makes a copy of itself.
\end{enumerate}

Consider the following code:

\begin{ffcode}
[qty] > order ? (*@\label{ln:order-start}@*)
  19.99 > price
  qty.mul > @
    price (*@\label{ln:order-stop}@*)
\end{ffcode}

This code is equivalent to the following \phic{} expression:
\begin{phiquation*}
\Big\{ order -> [[ @ -> \xi.qty.mul( 0-> \xi.price ), qty -> ?, price -> 19.99, L> |Order| ]] \Big\}.
\end{phiquation*}

\cref{fig:order} shows six cells that represent the \ff{order} object at runtime.
When being asked to \ff{take()}, cells behave differently.
Their behavior constitutes the semantics of the language.
Cells belong to one of four types, denoted by different colors: application, dispatch, formation, and decoration.

\begin{figure*}
\begin{mdframed}
\begin{tikzpicture}
[every node/.style={draw},
up/.style={draw=none, anchor=south west, label position=north west, align=left},
cell/.style={rotate=90, font={\scriptsize\sffamily}, draw=none, anchor=south west, label position=south west}]
\node [label={[up]$c_0$}, label={[cell]atom}, fill=purple!5] (c0)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\lambda\): & \ff{Order} \\
  \ff{base}: & \(c_1\) \\
  \end{tabularx}}};
\node [label={[up, text width=10em]$c_1$}, label={[cell]decoration}, fill=orange!5, below=of c0] (c1)
  {\parbox{9em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{decorator}: & \(c_2\) \\
  \ff{decoratee}: & \(c_5\) \\
  \ff{memo}: & \(\langle\varnothing, \varnothing\rangle\) \\
  \end{tabularx}}};
\node [label={[up, text width=10em]$c_2=[[ qty -> ?, \newline price -> ?, \rho -> ? ]]$}, label={[cell]formation}, below=1.2 of c1, fill=blue!5] (c2)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{qty}: & \(\varnothing\) \\
  \ff{price}: & \(c_7\) \\
  \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_3 = c_1.qty$}, label={[cell]dispatch}, right=of c0, fill=green!5] (c3)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attr}: & \ff{qty} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_4 = c_3.mul$}, label={[cell]dispatch}, fill=green!5, right=of c3] (c4)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_3\) \\
  \ff{attr}: & \ff{mul} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_6 = c_1.price$}, label={[cell]dispatch}, fill=green!5, right=of c1] (c6)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(c_2\) \\
  \ff{attr}: & \ff{price} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_5 = c_4(0-> c_6)$}, label={[cell]application}, fill=red!5, right=of c6] (c5)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{prototype}: & \(c_4\) \\
  \ff{attribute}: & \(\alpha_0\) \\
  \ff{argument}: & \(c_6\) \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$c_7 = \ff{19.99}$}, label={[cell]payload}, fill=cyan!5, below=of c6] (c7)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \(\Delta\): & \ff{19.99} \\
  \ff{base}: & \(\dead\) \\
  \end{tabularx}}};
\end{tikzpicture}
\end{mdframed}
\capt{Cells representing the object \ff{order} at the lines \ref{ln:order-start}--\ref{ln:order-stop}.}
\label{fig:order}
\end{figure*}

\subsection{Application}

The \emph{application} cell contains
\begin{inparaenum}[1)]
\item a ``prototype'' reference,
\item an attribute,
\item an ``argument'' reference,
and
\item a mutable initially blank ``memo'' reference.
\end{inparaenum}

On any request, if the memo is blank, the cell
\begin{inparaenum}[1)]
\item asks prototype to \ff{copy()} expecting a ``copy'' reference to be returned,
\item asks the copy to \ff{put(attribute, argument)},
and
\item stores the copy to the memo.
\end{inparaenum}
Then, the cell passes the request to the memo and returns the result.

\subsection{Dispatch}

The \emph{dispatch} cell contains
\begin{inparaenum}[1)]
\item a ``base'' reference,
\item an attribute,
and
\item a mutable initially blank ``memo'' reference.
\end{inparaenum}

On any request, if memo is blank, the cell
\begin{inparaenum}[1)]
\item asks base to \ff{take(attribute)} expecting a ``target'' reference to be returned,
\item asks target to \ff{put(\(\rho\),base)},
and
\item stores target to the memo.
\end{inparaenum}
Then, it passes the request to the memo and returns the result.

\subsection{Formation}

The \emph{formation} cell contains
\begin{inparaenum}[1)]
\item an associative array of attributes and references,
\item a possibly blank \(\lambda\)-asset,
and
\item a possibly blank \(\Delta\)-asset.
\end{inparaenum}

When being asked to \ff{put()}, the cell stores the reference to the array if the given attribute is not yet attached.
If the attribute is already attached, the cell returns \(\dead\).

When being asked to \ff{take()}, the cell returns the cell that is referenced by the corresponding attribute.
If the attribute is attached to a blank, the cell returns \(\dead\).

\subsection{Decoration}

The \emph{decoration} cell contains
\begin{inparaenum}[1)]
\item a ``decorator'' reference,
\item a ``decoratee'' reference,
and
\item a mutable initially blank ``memo'' associative array of attributes and references.
\end{inparaenum}

When being asked to \ff{take()}, the cell returns the cell stored in the memo.
If the memo is empty, the cell asks the decorator to \ff{take()}.
If \(\dead\) is returned, the cell asks the decoratee to \ff{take()}.
The cell stores the result into the memo and returns it.

\subsection{Atom}

The \emph{atom} cell contains
\begin{inparaenum}[1)]
\item a \(\lambda\)-asset attached to a function
and
\item a ``base'' reference.
\end{inparaenum}

On any request, the cell passes the request to the base and returns the result.
If the result is \(\dead\), the cell calls the function and then passes the request to the result of the function.
The execution of a function attached may be implemented via foreign function interface (FFI).

The function accepts a reference to the cell.

\subsection{Surging Object DiGraph}

A program is a static graph of cells, known as Surging Object DiGraph (SODG).
The compiler transforms a program into a SODG.
At runtime, additional cells may be created and then deleted in the SODG.
The cells created by the compiler may never be deleted.

The function may do the following with the SODG:
\begin{enumerate}
  \item \ff{formation(o, attr\(_0\), attr\(_1\), ...)} -- creates a new formation cell;
  \item \ff{dispatch(o, base, attr)} -- creates a new dispatch cell;
  \item \ff{application(o, proto, attr, arg)} -- creates a new application cell;
  \item \ff{payload(o, data, base)} -- creates a new payload cell;
  \item \ff{atom(o, function, base)} -- creates a new atom cell;
  \item \ff{put(o, attr, kid)} -- sets attribute of a formation cell.
\end{enumerate}

The code at lines \ref{ln:order-start}--\ref{ln:order-stop} may be transformed to a SODG using the following sequence of instructions:

\begin{ffcode}
formation(c1, "qty", "price", "cost")
dispatch(c2, c1, "qty")
dispatch(c3, c2, "mul")
dispatch(c5, c1, "price")
application(c4, c3, (*@\(\alpha_0\)@*), c5)
put(c1, "cost", c4)
\end{ffcode}

Both compile-time and runtime optimizations may infer attribute names.
For example, the \(\alpha_0\) attribute of the \(c_5\) cell may be replaced by the actual name.

\subsection{Deterministic Cells Destruction}

The function may not delete cell from the SODG.
Instead, they get deleted automatically.
All cell created by the function are deleted, except the cell that the function returns.
The objecellcts that are directly or indirectly referenced by the returned cell are not deleted either.
