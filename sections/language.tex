% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

% synthetic attributes
% const
% idempotence
% lints

% true, false, if
% try/catch
% seq, goto, while,
% tuples
% malloc
% number
% const

The entire syntax of the \eolang{} language in BNF is available on the first page of the \texttt{objectionary/eo} GitHub repository%
  \footnote{\url{https://github.com/objectionary/eo}}.
In this section, we only explain key concepts of the language.

\section{Informal Overview}

In runtime, every \eolang{} object is represented by an \emph{actor}.
On the surface, an actor resembles an associative array that responds to a few requests:
\begin{enumerate}
  \item \ff{take(attr)} returns a reference to a sub-actor, by provided attribute
  \item \ff{put(attr, actor)} saves a reference to a sub-actor, by the attribute
  \item \ff{delta()} turns itself to data
  \item \ff{copy()} makes a copy of itself
\end{enumerate}

Consider the following code:

\begin{ffcode}
[qty price] > order (*@\label{ln:order-start}@*)
  qty.mul > cost
    price (*@\label{ln:order-stop}@*)
\end{ffcode}

The code is equivalent to the following \phic{} expression:
\begin{phiquation*}
\Big\{ order -> [[ qty -> ?, price -> ?, cost -> \xi.qty.mul(\xi.price) ]] \Big\}
\end{phiquation*}

\cref{fig:order} shows five actors that represent the code in runtime.
When being asked to \ff{take()}, actors behave differently.
Their behavior constitute the semantic of the language.

\begin{figure*}
\begin{mdframed}
\begin{tikzpicture}
[every node/.style={draw},
up/.style={draw=none, anchor=south west, label position=north west, align=left},
actor/.style={rotate=90, font={\scriptsize\sffamily}, draw=none, anchor=south west, label position=south west}]
\node [label={[up, text width=10em]$b_1=[[ qty -> ?, price -> ?, cost -> b_4, \rho -> ? ]]$}, label={[actor]formation}, fill=blue!5] (b1)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{qty}: & \(\varnothing\) \\
  \ff{price}: & \(\varnothing\) \\
  \ff{cost}: & \(b_4\) \\
  \(\rho\): & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_2 = b_1.qty$}, label={[actor]dispatch}, above right=0 and 2.5 of b1, fill=green!5] (b2)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_1\) \\
  \ff{attr}: & \ff{qty} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_3 = b_2.mul$}, label={[actor]dispatch}, fill=green!5, right=of b2] (b3)
  {\parbox{7em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_2\) \\
  \ff{attr}: & \ff{mul} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\node [label={[up]$b_4 = b_3(0-> b_5)$}, label={[actor]application}, fill=red!5, below=of b3] (b4)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{prototype}: & \(b_3\) \\
  \ff{attr}: & \(\alpha_0\) \\
  \ff{argument}: & \(b_5\) \\
  \end{tabularx}}};
\node [label={[up]$b_5 = b_1.price$}, label={[actor]dispatch}, fill=green!5, left=of b4] (b5)
  {\parbox{8em}{
  \begin{tabularx}{\linewidth}{Xl}
  \ff{base}: & \(b_1\) \\
  \ff{attr}: & \ff{price} \\
  \ff{memo}: & \(\varnothing\) \\
  \end{tabularx}}};
\end{tikzpicture}
\end{mdframed}
\capt{Actors representing the program at the lines \ref{ln:order-start}--\ref{ln:order-stop}.}
\label{fig:order}
\end{figure*}

\subsection{Application}

The actor representing \emph{application} contains
\begin{inparaenum}[1)]
\item a ``prototype'' as actor reference,
\item an attribute,
and
\item an ``argument'' as actor reference.
\end{inparaenum}

On any type of request, the actor
\begin{inparaenum}[1)]
\item asks prototype to \ff{copy()} expecting a ``copy'' actor to be returned,
\item asks the copy to \ff{put(attribute, argument)},
and
\item passes the request to the copy.
\end{inparaenum}

\subsection{Dispatch}

The actor representing \emph{application} contains
\begin{inparaenum}[1)]
\item a ``base'' as actor reference,
\item an attribute,
and
\item a ``memo'' as a mutable, initially blank, reference to an actor.
\end{inparaenum}

On any type of request, the actor does two things.
First, if memo is blank, it
\begin{inparaenum}[1)]
\item asks base to \ff{take(attribute)} expecting a target to be returned,
\item asks target to \ff{put(\(\rho\),base)},
and
\item saves target to the memo.
\end{inparaenum}
Then, it passes the request to the memo.

\subsection{Formation}

The actor representing \emph{formation} contains an associative array of attributes and actor references.

When being asked to \ff{put()}, the actor saves the reference to the array, if given attribute is not yet attached.
If the attribute is already attached, the actor returns an error.

When being asked to \ff{take()}, the actor returns the actor reference that corresponds to the given attribute.
If the attribute is attached to a blank, the actor returns an error.
If the attribute is absent and the \(\varphi\)-attribute is present, the actor asks the actor referenced by the attribute to \ff{take()}.
If the \(\varphi\)-attribute is present but the \(\lambda\)-asset is present, the actor calls the function attached to the asset, it returns a reference, and the actor uses it to \ff{take()}.

When being asked to \ff{delta()}, the actor ...

