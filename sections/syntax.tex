% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

\section{Syntax}\label{sec:syntax}

The syntax of a program is defined by BNF in \cref{fig:ebnf}, where the starting symbol is \EbnfNonTerminal{Program}.

\begin{figure*}
\begin{mdframed}
\raggedright
\begin{ebnf}[8em]
<Program> := "\(\Phi\)" "\(\mapsto\)" <Expression> \\
<Expression> := <Formation> | <Application> | <Dispatch> | "\(\dead\)" \\
<Formation> := "\(\llbracket\)" <Binding> "\(\rrbracket\)" \\
<Application> := <Expression> "\(\lparen\)" <A-Pair> "\(\rparen\)" \\
<A-Pair> := <\(\tau\)-Pair> | <\(\alpha\)-Pair> \\
<Dispatch> := <Subject> "." <Attribute> \\
<Subject> := <Expression> | <Locator> \\
<Locator> := "\(\Phi\)" | "\(\xi\)" \\
<Binding> := <Pair> <Bindings> | \(\epsilon\) \\
<Bindings> := "," <Pair> <Bindings> | \(\epsilon\) \\
<Pair> := <\(\varnothing\)-Pair> | <\(\tau\)-Pair> | <\(\Delta\)-Pair> | <\(\lambda\)-Pair> \\
<\(\varnothing\)-Pair> := <Attribute> "\(\mapsto\)" "\(\varnothing\)" \\
<\(\tau\)-Pair> := <Attribute> "\(\mapsto\)" <Subject> \\
<\(\alpha\)-Pair> := <Alpha> "\(\mapsto\)" <Subject> \\
<\(\Delta\)-Pair> := "\(\Delta\)" "\(\phiDotted\)" <Data> \\
<\(\lambda\)-Pair> := "\(\lambda\)" "\(\phiDotted\)" <Function> \\
\end{ebnf}
\end{mdframed}
\capt{Syntax as a context-free grammar, in BNF.}
\label{fig:ebnf}
\end{figure*}

Besides the literals mentioned in the grammar in orange,
  the alphabet includes three non-terminals that rewrite to terminals as follows:
\begin{itemize}
  \item \EbnfNonTerminal{Attribute}: either \begin{inparaenum}[1)]
      \item Greek letter $@$,
      \item Greek letter $^$,
      or
      \item a string of lowercase English letters possibly with dashes inside, e.g. \enquote{\ff{price}} or \enquote{\ff{a-car}};
  \end{inparaenum}
  \item \EbnfNonTerminal{Data}: a sequence of bytes in hexadecimal format, e.g. \enquote{\ff{EF-41-5C}} is a sequence of three bytes, \enquote{\ff{42-}} is a one-byte sequence (with a trailing dash to avoid confusion with integers), and \enquote{\ff{-{}-}} (double dash) is an empty sequence of bytes;
  \item \EbnfNonTerminal{Function}: a string of English letters and numbers where the first symbol is an uppercase letter, e.g. \enquote{\ff{Sqrt}} or \enquote{\ff{F1}};
  \item \EbnfNonTerminal{Alpha}: a Greek letter \(\alpha\) with a non-negative whole-number index, e.g. \(\alpha_2\).
\end{itemize}

\Cref{tab:sugar} shows all possible syntax sugar.

\begin{table*}
\capt{Syntax sugar.}
\label{tab:sugar}
\newcommand\sugar[2]{$ #1 $ & $ #2 $ \\}
\newcommand\subs[1]{& \textcolor{gray}{(#1)} \\}
\begin{tabular}{ll}
\toprule
Syntax sugar & Its more verbose equivalent \\
\midrule
\sugar
  {e ( \tau_1 -> e_1 , \tau_2 -> e_2 , \dots )}
  {e ( \tau_1 -> e_1 )( \tau_2 -> e_2 ) \dots}
\sugar
  {e ( e_0 ,\; e_1 , \dots )}
  {e ( ~0 -> e_0 , ~1 -> e_1 , \dots )}
\sugar
  {\tau_1 ( \tau_2 ,\; \tau_3 , \dots ) -> [[ B ]]}
  {\tau_1 -> [[ \tau_2 -> ? , \tau_3 -> ? , \dots , B ]]}
\sugar
  {\tau_1 -> \tau_2}
  {\tau_1 -> \phiTerminal{\xi}.\tau_2}
\sugar
  {[[ B ]]}
  {[[ B , ^ -> ? ]] \quad\text{if}\; ^ \notin B}
\sugar
  {\texttt{\begin{CJK}{UTF8}{gbsn}"你好"\end{CJK}}}
  { Q.|string| ( Q.|bytes| ( [[ D> |E4-BD-A0-E5-A5-BD| ]] ) )}
  \subs{UTF-8 string}
\sugar
  {42}
  { Q.|number| ( Q.|bytes| ( [[ D> |40-45-00-00-00-00-00-00| ]] ) )}
  \subs{eight bytes per integer}
\sugar
  {3.14}
  { Q.|number| ( Q.|bytes| ( [[ D> |40-09-1E-B8-51-EB-85-1F| ]] ) )}
  \subs{eight bytes per number with a floating point}
\sugar
  {\Big\{ e \Big\}}
  { Q  -> e }
\bottomrule
\end{tabular}
\end{table*}
