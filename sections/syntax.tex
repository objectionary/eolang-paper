% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

\section{Syntax}\label{sec:syntax}

The syntax of a program is defined by BNF in \cref{fig:ebnf}, where the starting symbol is \EbnfNonTerminal{Program}.

\begin{figure*}
\begin{mdframed}
\raggedright
\begin{ebnf}[8em]
<Program> := "\(\Phi\)" "\(\mapsto\)" <Expression> \\
<Expression> := <Formation> | <Application> | <Dispatch> | "\(\dead\)" \\
<Formation> := "\(\llbracket\)" <Binding> "\(\rrbracket\)" \\
<Application> := <Expression> "\(\lparen\)" <A-Pair> "\(\rparen\)" \\
<A-Pair> := <\(\tau\)-Pair> | <\(\alpha\)-Pair> \\
<Dispatch> := <Subject> "." <Attribute> \\
<Subject> := <Expression> | <Locator> \\
<Locator> := "\(\Phi\)" | "\(\xi\)" \\
<Binding> := <Pair> <Bindings> | \(\epsilon\) \\
<Bindings> := "," <Pair> <Bindings> | \(\epsilon\) \\
<Pair> := <\(\varnothing\)-Pair> | <\(\tau\)-Pair> | <\(\Delta\)-Pair> | <\(\lambda\)-Pair> \\
<\(\varnothing\)-Pair> := <Attribute> "\(\mapsto\)" "\(\varnothing\)" \\
<\(\tau\)-Pair> := <Attribute> "\(\mapsto\)" <Subject> \\
<\(\alpha\)-Pair> := <Alpha> "\(\mapsto\)" <Subject> \\
<\(\Delta\)-Pair> := "\(\Delta\)" "\(\phiDotted\)" <Data> \\
<\(\lambda\)-Pair> := "\(\lambda\)" "\(\phiDotted\)" <Function> \\
\end{ebnf}
\end{mdframed}
\capt{Syntax as a context-free grammar, in BNF.}
\label{fig:ebnf}
\end{figure*}

Besides the literals mentioned in the grammar in orange,
  the alphabet includes three non-terminals that rewrite to terminals as follows:
\begin{itemize}
  \item \EbnfNonTerminal{Attribute}: either \begin{inparaenum}[1)]
      \item Greek letter \(\varphi\),
      \item Greek letter \(\rho\),
      or
      \item a string of lowercase English letters possibly with dashes inside, e.g. \enquote{\ff{price}} or \enquote{\ff{a-car}};
  \end{inparaenum}
  \item \EbnfNonTerminal{Data}: a sequence of bytes in hexadecimal format, e.g. \enquote{\ff{EF-41-5C}} is a sequence of three bytes, \enquote{\ff{42-}} is a one-byte sequence (with a trailing dash to avoid confusion with integers), and \enquote{\ff{-{}-}} (double dash) is an empty sequence of bytes;
  \item \EbnfNonTerminal{Function}: a string of English letters and numbers where the first symbol is an uppercase letter, e.g. \enquote{\ff{Sqrt}} or \enquote{\ff{F1}};
  \item \EbnfNonTerminal{Alpha}: a Greek letter \(\alpha\) with a non-negative whole-number index, e.g. \(\alpha_2\).
\end{itemize}

\Cref{tab:sugar} shows all possible syntax sugar.

\begin{table*}
\capt{Syntax sugar.}
\label{tab:sugar}
\newcommand\sugar[2]{$ #1 $ & $ #2 $ \\}
\newcommand\subs[1]{& \textcolor{gray}{(#1)} \\}
\newcommand\tto{\;\stx{\mapsto}\;}
\begin{tabular}{ll}
\toprule
Syntax sugar & Its more verbose equivalent \\
\midrule
\sugar
  {\stx{ QQ }}
  {\stx{ Q } \stx{.} |org| \stx{.} |eolang|}
\sugar
  {e \stx{(} \tau_1 \tto e_1 \stx{,}\; \tau_2 \tto e_2 \stx{,}\; \dots \stx{)}}
  {e \stx{(} \tau_1 \tto e_1 \stx{)}\stx{(} \tau_2 \tto e_2 \stx{)} \dots}
\sugar
  {e \stx{(} e_0 \stx{,}\; e_1 \stx{,} \dots \stx{)}}
  {e \stx{(} \alpha_0 \tto e_0 \stx{,}\; \alpha_1 \tto e_1 \stx{,}\; \dots \stx{)}}
\sugar
  {\tau_1 \stx{(} \tau_2 \stx{,}\; \tau_3 \stx{,}\; \dots \stx{)} \tto \stx{[[} B \stx{]]}}
  {\tau_1 \tto \stx{[[} \tau_2 \tto \stx{?} \stx{,}\; \tau_3 \tto \stx{?} \stx{,}\; \dots \stx{,}\; B \stx{]]}}
\sugar
  {\tau_1 \tto \tau_2}
  {\tau_1 \tto \stx{\xi}\stx{.}\tau_2}
\sugar
  {\stx{[[} B \stx{]]}}
  {\stx{[[} B \stx{,}\; \stx{\rho} \tto \stx{?} \stx{]]} \quad\text{if}\; \stx{\rho} \notin B}
\sugar
  {\texttt{\begin{CJK}{UTF8}{gbsn}"你好"\end{CJK}}}
  {\stx{ QQ } \stx{.} |string| \stx{(} \stx{ QQ } \stx{.} |bytes| \stx{(} \stx{[[} \stx{ D> }\; |E4-BD-A0-E5-A5-BD| \stx{]]} \stx{)} \stx{)}}
  \subs{UTF-8 string}
\sugar
  {42}
  {\stx{ QQ } \stx{.} |number| \stx{(} \stx{ QQ } \stx{.} |bytes| \stx{(} \stx{[[} \stx{ D> }\; |40-45-00-00-00-00-00-00| \stx{]]} \stx{)} \stx{)}}
  \subs{eight bytes per integer}
\sugar
  {3.14}
  {\stx{ QQ } \stx{.} |number| \stx{(} \stx{ QQ } \stx{.} |bytes| \stx{(} \stx{[[} \stx{ D> }\; |40-09-1E-B8-51-EB-85-1F| \stx{]]} \stx{)} \stx{)}}
  \subs{eight bytes per number with a floating point}
\sugar
  {\stx{\Big\{} e \stx{\Big\}}}
  {\stx{ Q } \tto e }
\bottomrule
\end{tabular}
\end{table*}
