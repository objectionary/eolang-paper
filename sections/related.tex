% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

In this section we analyze and categorize prior art related to our work.
Neither object-oriented formalism nor pure object-oriented languages are new research topics.
However, we identified certain gaps in existing studies that make us believe that our work has novelty.

\subsection{Object Calculi}

Attempts were made to formalize OOP and introduce object calculus, similar to lambda calculus~\citep{barendregt2012} used in functional programming.
For example, \citet{abadi1995imperative} suggested an imperative calculus of objects, which was extended by~\citet{bono1998imperative} to support classes, by~\citet{gordon1998concurrent} to support concurrency and synchronization, and by~\citet{jeffrey1999distributed} to support distributed programming.

Earlier, \citet{honda1991object} combined OOP and \(\pi\)-calculus in order to introduce object calculus for asynchronous communication, which was further referenced by~\citet{jones1993pi} in their work on object-based design notation.

A few attempts were made to reduce existing OOP languages and formalize what is left.
Featherweight Java is the most notable example proposed by~\citet{igarashi2001featherweight}, which omits almost all features of the full language (including interfaces and even assignment) to obtain a small calculus.
Later it was extended by~\citet{jagannathan2005transactional} to support nested and multi-threaded transactions.
Featherweight Java is used in formal languages such as Obsidian~\citep{coblenz2019} and SJF~\citep{usov2020}.

Another example is Larch/C++~\citep{cheon1994quick}, which is a formal algebraic interface specification language tailored to C++.
It allows interfaces of C++ classes and functions to be documented in a way that is unambiguous and concise.

Several attempts to formalize OOP were made by extensions of the most popular formal notations and methods, such as Object-Z~\citep{duke1991object} and VDM++~\citep{durr1992vdm}.
In Object-Z, state and operation schemes are encapsulated into classes.
The formal model is based upon the idea of a class history~\citep{duke1990towards}.
However, all these OO extensions do not have comprehensive refinement rules that can be used to transform specifications into implemented code in an actual OO programming language, as was noted by~\citet{paige1999object}.

\citet{bancilhon1985calculus} suggested an object calculus as an extension to relational calculus.
\citet{jankowska2003anotheroop} further developed these ideas and related them to a Boolean algebra.
\citet{leekwakryu1996transform} developed an algorithm to transform an object calculus into an object algebra.

However, all these theoretical attempts to formalize OO languages were not able to fully describe their features, as was noted by~\citet{nierstrasz1991towards}: ``The development of concurrent object-based programming languages has suffered from the lack of any generally accepted formal foundations for defining their semantics.''
In addition, when describing the attempts of formalization, \citet{eden2002visual} summarized: ``Not one of the notations is defined formally, nor provided with \nospell{denotational} semantics, nor founded on axiomatic semantics.''
Moreover, despite these efforts, \citet{ciaffaglione2003reasoning,ciaffaglione2003typetheories,ciaffaglione2007theory_of_contexts} noted in their series of works that relatively little formal work has been carried out on object-based languages, and it remains true to this day.

\subsection{Pure Object-Oriented Languages}

Since 1966, when Simula~\citep{dahl1966simula} was created and the term ``object-oriented programming'' was later coined by
Alan Kay~\citep{kay97keynote}, the exact characteristics defining object-orientation have been ambiguous~\citep{stefik1985object,madsen1988object,armstrong2006quarks}.
Initially, several key features were proposed by various authors~\citep{nygaard1986basic,stroustrup1987object,meyer1988object,korson1990understanding,wirfs1990designing,coad1991object,booch1994object}, including objects, classes, polymorphism, inheritance, abstraction, encapsulation, and dynamic binding.
Over time, object-orientation has been expanded to include additional elements such as, for example, types, traits, concurrency, annotations, records, and aspects.

Meanwhile, some programming languages claim to be ``pure'' object-oriented.
According to \citet{chambers1991making}, this designation implies that ``all computation, including low-level operations such as variable access, arithmetic, and array indexing, is performed by sending messages to objects.''
A broader definition by \citet{west2004object} suggests that being ``pure'' means ``everything is an object,'' which implies the exclusion of non-object entities such as procedures and operators~\citep{joque2016invention}.
\Cref{tab:languages} lists several object-oriented languages that describe themselves as ``pure'' in their documentation, yet include additional constructs beyond mere objects.

\begin{table}
\caption{A non-exhaustive list of object-oriented languages that claim to be ``pure.''}
\label{tab:languages}
\input{sections/tab-other-languages}
\end{table}

Even though ``pure'' object-orientation may not be a virtue by itself, we claim that \eolang{} is the only object-oriented programming language that has nothing but objects.
