% SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
% SPDX-License-Identifier: MIT

\section{Operators}

In this section we introduce a family of semantic operators defined on \(\phi\)-expressions.
These operators do not extend the syntax of the calculus.
Instead, they describe systematic transformations of expressions that reveal, modify, or project their semantic content.
Each operator is defined in terms of the reduction semantics introduced earlier
  and preserves the core meaning of expressions while possibly changing their form or role.

\subsection{Contextualization}\label{sec:contextualization}
\label{r:contextualize}
\newcommand\ctx[2]{\lceil #1 \;\textcolor{gray}{\shortmid}\; #2 \rfloor}

\begin{definition}[Contextualization]
The \emph{contextualization} total function \(\mathbb{C} : \mathcal{E} \times \mathcal{B} \to \mathcal{E}\)
  denoted as \( \ctx{e}{b} \), which removes \(\phiTerminal{\xi}\) from expression,
  is defined by induction:
\begin{enumerate}[label=\(\mathbb{C}_\arabic*:\),ref=\ensuremath{\mathbb{C}.\arabic*}]
  \item\label{C:xi} $ \ctx{ \phiTerminal{\xi} }{b} \trans b $,
  \item\label{C:Phi} $ \ctx{ Q }{b} \trans Q $,
  \item\label{C:forma} $ \ctx{ [[ B ]] }{b} \trans [[ B ]] $,
  \item\label{C:dead} $ \ctx{ T }{b} \trans T $,
  \item\label{C:dot} $ \ctx{ e.\tau }{b} \trans \ctx{e}{b}.\tau $,
  \item\label{C:app} $ \ctx{ e_1( \tau -> e_2 ) }{b} \trans \ctx{e_1}{b}( \tau -> \ctx{e_2}{b} ) $.
\end{enumerate}
\end{definition}

\ifdefined\examples
\Cref{app:contextualization-examples} demonstrates how the contextualization function works through examples.
\fi

\subsection{Normalization}\label{sec:normalization}

An expression that may be rewritten by the \emph{rules} (or \emph{reductions})
listed in \cref{fig:reduction} is a \emph{reducible} expression.
The notation \(e_1 \trans e_2\), optionally followed by a condition,
denotes a reduction of \(e_1\) to \(e_2\), if the condition holds.

These rules may be applied in any order.

A specific reduction may be denoted, for example, as \(\trans_{\nameref{r:dot}}\),
  or just \(\trans\) when no specific reduction is meant.
The notation \(e_1 \strans e_2\) denotes a reflexive transitive
  closure of all reductions, so that there is a possibly empty finite
  sequence of reductions between \(e_1\) and \(e_2\).

An expression that has no more possible applications of reductions
  is \emph{irreducible} or a \emph{normal form}, denoted as \(\nf{}_i\)
  ranging over \(\mathcal{N} \in \mathcal{E}\).
Thus, \(\nf\) is a normal form of \(e\) if \(e \strans \nf\) and
  there is no expression \(e_1\) such that \(\nf \trans e_1\).

\begin{figure*}
\newcommand\trrule[5][]{%
  \newrule[#1]{#2}:
  &
  { $ #3 $ }
  \(\trans\)
  { $ #4 $ }
  \quad #5
  \\%
}
\begin{mdframed}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{rl}
\trrule{copy}
  { [[ B_1, \tau -> ?, B_2 ]] ( \tau -> e ) }
  { [[ B_1, \tau -> n, B_2 ]] }
  { if \( \ctx{e}{e\textsuperscript{\(\varsigma\)}} \strans n \) }
\trrule[\alpha]{alpha}
  { b ( \phiTerminal{\alpha_i} -> e ) }
  { b ( \tau -> e) }
  { if $ \tau \in b $ and \( \ordinal{\tau}{\bar{b}} = i \) }
\trrule{dot}
  { [[ B_1, \tau -> \nf, B_2 ]].\tau }
  { \ctx{\nf}{n\textsuperscript{\(\varsigma\)}} ( \rho -> n\textsuperscript{\(\varsigma\)} ) }
  { }
\trrule[\varphi]{phi}
  { b.\tau }
  { b.@.\tau }
  { if \( \tau \notin b \) and $ @ \in b $ }
\trrule{stay}
  { b( \rho -> e ) }
  { b }
  { if $ ^ \in b $ }
\trrule{over}
  { b( \tau -> e) }
  { T }
  { if $\tau \in b $ and $ \tau \not= ^ $ }
\trrule{stop}
  { b.\tau }
  { T }
  { if $ [ \tau {,}\; @ {,}\; L ] \cap b = \emptyset $ }
\trrule{null}
  { [[ B_1, \tau -> ?, B_2 ]].\tau }
  { T }
  { }
\trrule{miss}
  { b ( \tau -> e ) }
  { T }
  { if \( \tau \notin b \) and \( \tau \notin [ \phiTerminal{\alpha_0}, \phiTerminal{\alpha_1}, \dots ] \) }
\trrule{dd}
  { T.\tau }
  { T }
  { }
\trrule{dc}
  { T ( \tau -> e ) }
  { T }
  { }
\end{tabular}
\end{mdframed}
\capt{Reduction rules.}
\label{fig:reduction}
\end{figure*}

\ifdefined\examples
\Cref{app:normalization-examples} demonstrates how normalization works through examples.
\fi

\subsection{Equivalence}\label{sec:equivalence}

\begin{definition}[Equivalence]
Two expressions are said to be syntactically equivalent or just
\textbf{equivalent} (denoted by \(\equiv\)) if their normal forms are
syntactically identical.
\end{definition}

\Cref{fig:equivalence} shows some equivalence properties that hold.

\begin{figure*}
\begin{mdframed}
\begin{phiquation*}
e ( \tau_1 -> e_1) ( \tau_2 -> e_2 ) \equiv e ( \tau_2 -> e_2) (\tau_1 -> e_1)
\text{Commutativity of Application}

e.\tau ( \rho -> e_2 ) \equiv e.\tau
\text{Redundancy of Adoption}
\end{phiquation*}
\end{mdframed}
\capt{Equivalence properties that hold.}
\label{fig:equivalence}
\end{figure*}

\subsection{Morphing}\label{sec:morphing}

The \emph{morphing} partial function
  \(\mathbb{M} : \mathcal{E} \times \mathcal{B} \times \mathcal{S} \rightharpoonup \mathcal{P} \times \mathcal{S} \)
  maps expressions to primitives, possibly modifying the \emph{state} of evaluation.
The inference rules at \cref{fig:morphing} inductively describe the algorithm of morphing.

\begin{figure*}
\begin{mdframed}
\begin{phiquation*}
\newrule{Mprim} \
\frac \
{  } \
{ \langle e{,}\; u{,}\; s \rangle \stepto \langle p{,}\; s \rangle }  \
\;\text{if}\; e \in \mathcal{P} \
\quad\quad \
\newrule{Mnmz} \
\frac \
{ \langle \nf{,}\; u{,}\; s_1 \rangle \stepto \langle p{,}\; s_2 \rangle } \
{ \langle e{,}\; u{,}\; s_1 \rangle \stepto \langle p{,}\; s_2 \rangle }  \
\;\text{if}\; e \strans \nf \;\text{and}\; e \not\equiv n

\newrule[\lambda]{Mlambda} \
\frac \
{ \langle e \bullet t{,}\; u{,}\; s_2 \rangle \stepto \langle p{,}\; s_3 \rangle} \
{ \langle  [[  B_1 ,  L>  f , B_2  ]]  \bullet{} t{,}\; u{,}\; s_1 \rangle \stepto \langle p{,}\; s_3 \rangle }  \
\;\text{if}\; f {(} [[ B_1, B_2 ]] {,}\; u{,}\; s_1 {)} \to \langle e{,}\; s_2 \rangle

\newrule[\Phi]{Mphi} \
\frac \
{ \langle e \bullet{} t{,}\; u{,}\; s_1 \rangle \stepto \langle p{,}\; s_2 \rangle} \
{ \langle Q.\tau \bullet{} t{,}\; u{,}\; s_1 \rangle \stepto \langle p{,}\; s_2 \rangle }  \
\;\text{if}\; u = [[  B_1 , \tau -> e, B_2 ]]
\end{phiquation*}
\end{mdframed}
\capt{Morphing rules.}
\label{fig:morphing}
\end{figure*}

The notation \(\langle e, u, s_1 \rangle \stepto \langle p, s_2 \rangle\)
  means that \(\mathbb{M}(e, u, s_1)\) evaluates to \(p\), thus \emph{morphing} \(e\)
  with a side-effect of changing \(s_1\) to \(s_2\),
  in the universe \(u\).

In \nameref{r:Mlambda}, the function \(f\) is called by value.

\subsection{Dataization}\label{sec:dataization}

The \emph{dataization} partial function
\(\mathbb{D} : \mathcal{E} \times \mathcal{B} \times \mathcal{S} \rightharpoonup \mathcal{D} \times \mathcal{S}\)
maps expressions to data, possibly modifying the \emph{state} of evaluation, in a given context.
The inference rules in \cref{fig:dataization} inductively describe the algorithm of dataization.

\begin{figure*}
\begin{mdframed}
\begin{phiquation*}
\newrule[\Delta]{delta} \
\frac \
{ } \
{ \langle [[ B_1, D> \delta, B_2 ]] {,}\; u {,}\; s \rangle \stepto \langle \delta {,}\; s \rangle } \
\quad \
\newrule{norm} \
\frac{ \langle p {,}\; u {,}\; s_1 \rangle \stepto \langle \delta {,}\; s_2 \rangle }{ \langle e {,}\; u {,}\; s_1 \rangle  \stepto \langle \delta {,}\; s_2 \rangle } \
\;\text{if}\; \mathbb{M} {(} e {,}\; u {,}\; s_1 {)} \to \langle p {,}\; s_2 \rangle

\newrule{box} \
\frac \
{ \langle \ctx{e}{e\textsuperscript{\(\varsigma\)}} {,}\; u {,}\; s_1 \rangle \stepto \langle \delta {,}\; s_2 \rangle } \
{ \langle [[ B_1, @ -> e, B_2 ]] {,}\; u {,}\; s_1 \rangle  \stepto \langle \delta {,}\; s_2 \rangle } \
\;\text{if}\; [ D {,}\; L ] \cap {(} B_1 \cup B_2 {)} = \emptyset
\end{phiquation*}
\end{mdframed}
\capt{Dataization rules.}
\label{fig:dataization}
\end{figure*}

The rules \nameref{r:box} and \nameref{r:phi} coexist because
$D \notin \mathcal{T}$, thus making the expression $ [[ @ -> 42 ]].D $ invalid.

The notation \(\langle e, u, s_1 \rangle \stepto \langle \delta, s_2 \rangle\)
  means that \(\mathbb{D}(e, u, s_1)\) evaluates to \(\delta\),
  thus \emph{dataizing} \(e\) with a side-effect of changing the state of evaluation \(s_1\) to \(s_2\), in the universe \(u\).
The notation \(\mathbb{D}(e, u)\) is a shortened form of \(\mathbb{D}(e, u, \varnothing_s)_{(1)}\),
  which is a \emph{pure} dataization --- inputting an empty state of evaluation and ignoring
  the output state of evaluation.
Here and later, the notation \(x_{(i)}\) denotes the \(i\)-th element of the tuple \(x\).

\begin{lemma}
The dataization function is partial, because not every primitive contains $D$-asset.
\end{lemma}

\ifdefined\examples
\Cref{app:dataization-examples} demonstrates how the dataization function works through examples.
\fi

\subsection{Congruence}

\begin{definition}[Congruence]
Two expressions \(e_1\) and \(e_2\) are said to be behaviorally equivalent
  or \textbf{congruent} (denoted by \(\cong\)) if for any state \(s\) and any context \(b\):
  \(\mathbb{D}(e_1, b, s) = \mathbb{D}(e_2, b, s)\).
\end{definition}

Two congruent expressions may be non-equivalent, for example:
\begin{phiquation*}
\Big\{ \tau_1 -> [[ foo -> ?, D> 01-02 ]], \tau_2 -> [[ bar -> ?, D> 01-02 ]] \Big\}
Q.\tau_1 \cong Q.\tau_2 \;\not\to\; Q.\tau_1 \equiv Q.\tau_2 {.}
\end{phiquation*}
